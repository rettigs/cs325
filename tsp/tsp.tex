\documentclass{article}
\usepackage{amssymb}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{mathtools}
\usepackage{verbatim}

\geometry{letterpaper, portrait, margin=1in}

\title{CS325 - TSP Project}
\author{Group \#6 \\ William Jernigan, Alexander Merrill, Sean Rettig}
\date{\today}

\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% University Assignment Title Page 
% LaTeX Template
% Version 1.0 (27/12/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% WikiBooks (http://en.wikibooks.org/wiki/LaTeX/Title_Creation)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
% 
% Instructions for using this template:
% This title page is capable of being compiled as is. This is not useful for 
% including it in another document. To do this, you have two options: 
%
% 1) Copy/paste everything between \begin{document} and \end{document} 
% starting at \begin{titlepage} and paste this into another LaTeX file where you 
% want your title page.
% OR
% 2) Remove everything outside the \begin{titlepage} and \end{titlepage} and 
% move this file to the same directory as the LaTeX file you wish to add it to. 
% Then add \input{./title_page_1.tex} to your LaTeX file where you want your
% title page.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{titlepage}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for the horizontal lines, change thickness here

\center % Center everything on the page
 
\textsc{\LARGE Oregon State University}\\[1.5cm] % Name of your university/college
\textsc{\Large CS325: Analysis of Algorithms}\\[0.5cm] % Major heading such as course name
\textsc{\large Group \#6}\\[0.5cm] % Minor heading such as course title

\HRule \\[0.4cm]
{ \huge \bfseries TSP Project}\\[0.4cm] % Title of your document
\HRule \\[1.5cm]

\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
\emph{Authors:}\\
William \textsc{Jernigan}\\
Alexander \textsc{Merrill}\\
Sean \textsc{Rettig}
\end{flushleft}
\end{minipage}
~
\begin{minipage}{0.4\textwidth}
\begin{flushright} \large
\emph{Instructor:} \\
Dr. Glencora \textsc{Borradaile}\\
\emph{\\Teaching Assistant:} \\
Spencer \textsc{Hubbard}
\end{flushright}
\end{minipage}\\[4cm]

{\large \today}\\[3cm] % Date, change the \today to a set date if you want to be precise

\vfill % Fill the rest of the page with whitespace

\end{titlepage}
\part*{Our technique}
After trying a few algorithms, we realized that we had two separate types of algorithms: those which generated a tour (generator: e.g. nearest neighbor) and those which filtered through the tour and improved the cost of the tour (filter: e.g. genetic modification). Here we present our best combination of generator and filter, then the other generators and filters we tried.
\part*{Best Generator and Best Filter}
\section*{Grow Inject}%growinject
We start with a set of three connected cities, the smallest complete circuit that doesn't loop back on itself.We then go through a series of iterations in order to add every city to the path. For each iteration, we add one city by calculating the path increase of injecting each remaining city into each edge in the current path and using the best one.
\section*{Inject3}
TODO: stuff

\part*{Other generators}

\section*{Nearest Neighbor}%nn
As one of our earlier algorithms, nearest neighbor ran fairly quickly but produced suboptimal tours in comparison to most of our other generators. This generator always started its tour at the first city given in the input. Asymptotic runtime: $\Theta (n^2)$

\section*{Best of Nearest Neighbor}%nnbest
Since nearest neighbor always started with the first given city, we thought that varying the start city would produce better results. Nearest neighbor can produce a different result based on the starting city, so we ran nearest neighbor for all possible starting cities and selected the best result. Asymptotic runtime: $\Theta (n^3)$

\section*{Most common paths from Nearest Neighbor}%nncommon
This generator first gets all the nearest neighbor tours generated by using each city as a starting point. It then creates a graph where the weights of the edges are the number of times a path between the two cities occurred in all the nearest neighbor tours. Finally, for each possible starting city, it creates a tour by greedily taking the path most travelled from the current city to another city. The best tour from that final step is selected. Asymptotic runtime: $\Theta (n^3 * n^2 * n^3) = \Theta (n^7)$.

\section*{Greedy Cluster Merge}%gcm
We got this idea from group 14. The two cities which are closest together are connected, then treated as one city, or a cluster. Then, the next closest cities (or clusters) are connected. This continues until a chain connecting all cities is formed. Then the front of the chain and the back of the chain are connected to make the tour. Asymptotic runtime: $\Theta ()$

\section*{Grow Inject}%growinject
We start with a set of three connected cities, the smallest complete circuit that doesn't loop back on itself.We then go through a series of iterations in order to add every city to the path. For each iteration, we add one city by calculating the path increase of injecting each remaining city into each edge in the current path and using the best one.

\section*{Permutations brute force}%brute
Our only exact algorithm, this simply computes all possible tours and chooses the best one. This becomes infeasible even with 40 cities.?!?!! TODO Asymptotic runtime: $\Theta (n!)$ a.k.a $\Theta (no)$

\part*{Other filters}

\section*{Injection}%inject
This filter takes a city, breaks it's existing edges and connects those two cities together, then injects the now free city it in an edge between two other points. Then the new path length is compared to the old path length and if it's shorter, the new path is kept. We iterate over every edge with every city until we cannot make any improvements in a full cycle.

\section*{Swap}%swap
Swap takes two cities in a path, swaps their order, then checks whether the resulting path is shorter and to be kept. Initially we did this by swapping neighbors, that is to say in the path a,b,c,d we swap a and b to get b,a,c,d, and iterating over the entire path. Once we got that working, we implemented this genetically (explained later) then iteratively where every point is checked against every other point until there is no path improvement in an entire cycle. Swap is fundimentally a subset of Injection and has been less effective in the sample sets.

\section*{Genetic}
Genetic algorithms take existing functions and apply them randomly to a dataset created by a generator to try to come up with better solutions. It ends up being functional and resulting in better paths but it's ultimately non-deterministic and therefore not optimal. We made genetic implementations of both our swap function and our injection function.

\part*{Results}
INSERT GRAPH OF TOUR LENGTHS PRODUCED BY GENERATOR+FILTER COMBOS


\part*{Sources}


\end{document}
